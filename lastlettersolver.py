# -*- coding: utf-8 -*-
"""LastLetterSolver.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_jSwWHmne74TtBIUN4sQu8jg5d1UoKx3

Given a list of countries and/cities and a starting value, the algorithm brute force generates a tree of every possible combination of places.

>
Results are then shown of the longest chain, and length of chain.
>
Input a country/location and number of generations.
"""

import pandas as pd
import numpy as np
import array


# kinda like playing dominoes


data = pd.read_csv('countries.txt', sep=" ", header=0)  # imports text file as dataframe and has the header
dataLength=len(data)

# create extra colunms for data
fLet = [None] * dataLength
lLet = [None] * dataLength
ID = np.zeros(dataLength)  # to do: change 196 to num rows in txtfile
matching = np.ones(dataLength)  # first and last letter matching

data['First'] = fLet
data['Last'] = lLet
data['ID'] = ID
data['Matching'] = matching

i = 0
numDupes = 0
for index, rows in data.iterrows():  # for each country/row

    data.at[i, 'First'] = (data.at[i, 'COUNTRIES'][0].lower())  # gets the first letter in lowercase
    data.at[i, 'Last'] = data.at[i, 'COUNTRIES'][-1]  # gets the first letter
    data.at[i, 'ID'] = i + 1  # sets the ID, just in case

    if (data.at[i, 'First'] == data.at[i, 'Last']):
        data.at[i, 'Matching'] = 0  # unmatched are 0, matched are 1-- helps for sorting
        numDupes += 1  # 13 duplicate words that dont really help much
    i += 1

##gets the first 'last letter' and sorts the dataframe  1


print('What is the starting word')
x = input().lower()[-1]  #last letter, TODO fn to check and remove input x 
# x= 'b'

print('How many generations')
gen=input()
#gen=3



j = 0
k = 0


# create a new useable list
global dataframe
dataframe = data.sort_values(by=['Matching', 'COUNTRIES'],
                             ascending=True)  # sorts first by matchings, than alphabetically

#setting up the initial array

initialData =[ [0,[0], [x]]] 
newData= np.array(initialData, dtype="object")   #ndarray? for indexing w array

global soln
soln = np.array([ [[0,[], [x]]] ],dtype="object")

def setup(soln,k):
  listCountryIndex = (dataframe[dataframe["First"]==x].index.values) #gives an array of all the indexes of countires with 'x' as first letter
  j=0
  for rIndex in listCountryIndex:
    
    wordToAdd=dataframe.at[listCountryIndex[j-1],"COUNTRIES"] #the word that is at j that should be added
    package= np.array([[[k,[rIndex],[x, wordToAdd]]]],dtype="object") #array for the loop with the node, indexToRemove, and word to add
    soln = np.append(soln,package, axis=0)
    j+=1
  return(soln)


k=1 #the node
zed = setup(soln,k)

#repeatable part of continuting chain

k=1 #the node
zed = setup(soln,k) #creates an ARRAY  #k could just be 1
initalLength=len(zed)






while k<int(gen):                       #k<8 gives how long chain should be
  k+=1  #new level
  m=0  #for each level, m represents the diffent new parents
  j=0 #for the children increments

  currentArray=zed[(zed[:,0,0] == (k-1))] #filter: sort by first column#zed array withOnlu the k-1 for parents 

  #fixes bug where the last chronological/index appears first
  currentArray=np.roll(currentArray, -1,axis=0) #moving first to last 
  ##


  for pRow in currentArray: #eachParentRow(parents) row in currentArray: each parent
    x=pRow[-1][-1][-1][-1][-1]  #the lastest last character in the array
    
    newDataFrame=dataframe.drop(pRow[0][1])   #new set is a set without the already used data
    
    #listCOuntryIndex= gets countries with the propper letter
    listCountryIndex = (newDataFrame[newDataFrame["First"]==x].index.values) #gets index of countries with the propper letter

    # droppingIndexes=[] #list of indexes to drop 
    for rIndexs in listCountryIndex: #eachposibleCountryInext: each possible child 
      
      # if rIndex in pRow[0][1]:
      droppingIndexes=[] #list of indexes to drop 
      wordsList=pRow[0][2][:]
      # wordToAdd=#similar to before, based on j

      wordToAdds=newDataFrame.at[listCountryIndex[j],"COUNTRIES"] #gets one of the possible words to add
      wordsList.append(wordToAdds)

      droppingIndexes= np.concatenate((pRow[0][1], rIndexs), axis=None) #1Darray of all index to remvote using the current list and the current index

                                               #remove bracket           # [0][:]
      packageL= np.array([[[k,droppingIndexes,wordsList]]],dtype="object") #array for the loop with the node, indexToRemove, and word to add[:]
      zed = np.append(zed,packageL, axis=0 )
      
 
      j+=1 #j++; shhh
    j=0 #reset this boy
    m+=1
    
    

#optimiations TODO: skip throught the matching As - how many countries end with a? perhaps remove the 'matching=0' coutnries and add 7 or 1 based on the last most number 
              #deleting AA-matching, then add matching ones length to LongestRowLength if ends with A/S

#using zed to get the solution

longestRow=[]
longestRowLength=0
for solnRows in zed:
  # print(solnRows[0][2])
  if len(solnRows[0][2]) >longestRowLength:
    
    longestRowLength=len(solnRows[0][2])
    longestRow=solnRows

print('Longest chain length: ')
print(longestRowLength)

print('Longest chain: ')
print(longestRow[0][2])

print('Longest chain row: ')
print(longestRow)

"""Issues:

-when using a dataset of 196 locations(all countries) generation>4 take minutes-hours without optimizations

TODO:

-function to remove input place from data list

-function to remove locations that start and end with the same letter, than add them to the last/longest chains
"""

print(dataframe)
print(zed)